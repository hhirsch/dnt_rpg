\documentclass[ letterpaper,12pt]{article}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{epsfig}

\begin{document}

\title{\textbf{DNT Script Language - 0.3}}

\author
{
DNTeam
}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Overview}

   The DNT AI Language was created to write AI and mission scripts for the
DccNiTghtmare computer game. 

   Why write a new language instead of using an existed one? Simple: first we
tried {\it LUA} as the game script language, but its integration with C++ and
poor compatibility between versions forced us to abandon the use. At the other
hand, a language implemented at the core of the game engine can be much more
optimized and extensible than a generic one.

\section{Restrictions}

\subsection{Expressions/Lines}
An expression must be entirely at the same line. So,

\begin{verbatim}
a = 25 + 45 + b * (d + e);
\end{verbatim}

{\bf is valid}, but

\begin{verbatim}
a = 25 + 45 + b 
    * (d + e);
\end{verbatim}

{\bf isn't}.

\subsection{Function Parameters}

Function parameters must be variables: you can't pass constants to funcions.
For Example:

\begin{verbatim}
   posX = 3500
   posZ = 3200
   moveToPosition(SELF_CHARACTER, posX, posZ)
\end{verbatim}

{\bf will work}, but:

\begin{verbatim}
   moveToPosition(SELF_CHARACTER, 3500, 3200)
\end{verbatim}

{\bf won't}.

\section{Comments}
 
   A comment is a line with its first valid character equal to '\#'. For
example:

\begin{verbatim}
   # This script is a test to the DNT script language
   # actually, it don't do anything util.
\end{verbatim}

\section{Separators}

   The separators, as the name suggest, separate terms in the language. They
are:

\begin{itemize}
\item{Comma: ','}
\item{Semi Colon: ';'}
\item{Space: ' '}
\item{Tab: '/t'}
\item{New Line: '/n'}
\item{Null: '/0'}
\end{itemize}

Any separator is valid at any time. {\it For example:}

\begin{verbatim}
int posX posZ
\end{verbatim}

{\it is the same of:}

\begin{verbatim}
int posX,posZ;
\end{verbatim}

\section{Variables}

\subsection{Declaration}

To declare a variable the expression is:

\begin{verbatim}
type separator name [separator name]
\end{verbatim}

For example, some valid definitions:

\begin{verbatim}
bool control
int posX posZ
int time, value
float dist; mean, sum;
\end{verbatim}

\subsection{Types}

Note: for scripts that keeps runnig for more than one map (mission scripts, for
example), {\bf don't keep variables} that will change it's value (or existence)
at maps (for example, don't keep NPC characters as variables, instead get them
with functions:

\begin{verbatim}
if(inventoryHave(getNPCByName(logan),objFile))
end
\end{verbatim}

{\it will work}, but

\begin{verbatim}
character c
c = getNPCByName(logan)
if(inventoryHave(c, objFile))
end
\end{verbatim}

{\it isn't athomical} and can give you {\bf errors}.)

\subsubsection{void}

The void type is as in C/C++: a representation of an empty set of values.

\subsubsection{bool}

The bool type is a boolean, taking values {\it true} or {\it false}.

\subsubsection{int}

The integer type represents a discret number.

\subsubsection{float}

The float type represents a float point number.

\subsubsection{string}

The string type represents a character string. String constants must begin and
end with ``. For Example:

\begin{verbatim}
"This is a string constant!"
\end{verbatim}

\subsubsection{character}

The character type represents a game character, playable or non-playable.

\section{Operations}

An operation must be done with compatible types.

\subsection{Parenthesis}

Parenthesis can be used to group operations, just keeping in mind that any open
paranthesis '(' must have a close ')' one. And {\it vice-versa}.

\subsection{Math Operators}

\begin{itemize}
\item{Addition: '+'}
\item{Subtraction: '-'}
\item{Multiplication: '*'}
\item{Division: '/'}
\item{Modulus: '\%'}
\item{Assign: '='}
\end{itemize}

\subsection{Logical Operators}

\begin{itemize}
\item{Equal: "=="}
\item{Not Equal: "!="}
\item{Lesser: "<"}
\item{Greater: ">"}
\item{Greater Equal: ">="}
\item{Lesser Equal: "<="}
\item{And: "\&\&"}
\item{Or: "||"}
\item{Not: '!'}
\end{itemize}

\section{Flux Control}

\subsection{Script Declaration}

All scripts must have a {\it script()} marking its begining. A {\it script()}
must have an {\it end}.

\begin{verbatim}
script()

   #its a multiple variable definition. Each variable
   #is separated with spaces.
   int a b

   #some maths
   a = 2
   b = 10
   a=b + a
end
\end{verbatim}

\subsection{Conditional}

The conditional flux control is an {\it 'if'}. An {\it 'if'} must have an {\it
end} or {\it else}. An {\it else} must have an {\it end} or {\it else}. {\it
else if} is valid. Examples:

\begin{verbatim}
   if( (c > 40) && (a > 10) && (!variavel) )
      c = 12;
      if(c < 40)
         c = 40
      else
         c = c*2+20
      end
   else
      c = d
   end
\end{verbatim}

\begin{verbatim}
   if(a >= 2)
      b = 1
   else if(a <= 0)
      b = 2
   else
      b = 3;
   end
\end{verbatim}

\subsection{Iterational}

The iterational flux control is an {\it while}. Each {\it while} must have an
{\it end}. Examples:

\begin{verbatim}
   while(count <= 5)
      count = count + 1
      c = c + (count * 2)
   end
\end{verbatim}

\begin{verbatim}
   while(true)
      if(control)
         posX = 3500
         posZ = 3200
         moveToPosition(SELF_CHARACTER, posX, posZ)
         posX = 3600
         posZ = 3200
         moveToPosition(SELF_CHARACTER, posX, posZ)
         control = false
      else
         setIdle(SELF_CHARACTER)
         time = 10
         wait(time)
         control = true
      end
   end
\end{verbatim}


\section{Functions}


\subsection{User Defined Functions}

   At this time, you can't implement functions at the script. This is a feature
that we plan to put later on the language if we need it.

\subsection{Pending Actions}

   There are two types of functions, those that can be done in a time lesser of
a render cycle, and those that remains for more than one cycle. For example,
verify the current character position is done in a time lesser than the render
cycle, but make a character move from its current position to another one is an
operation that requires more than one render cycle to finish.

   For those functions types, the interpreter puts them at an {\it Action 
Controller} and wait for the action's end (with success or not) to continue 
the script interpretation. 

\subsection{Quick Pointers}

The quick pointer are pointers to somethings in game that can be used as a
global variable {\it (but can't have his value directly changed)}.

\subsubsection{SELF\_OBJECT}
{\bf type:} string

The {\it SELF\_OBJECT} is the representation of the object owner of the script
(if one exists). This variable is available when the script is one that
controls some object behaviour.

\subsubsection{SELF\_CHARACTER}
{\bf type:} character

The {\it SELF\_CHARACTER} is the representation of the character owner of the
script (if one exists). This variable is available when the script is one that
controls some character behaviour (in combat or not).

\subsubsection{SELF\_MISSION}
{\bf type:} string

The {\it SELF\_MISSION} is the representation of the mission owner of the script
(if one is defined). This variable is only available for mission's scripts.

\subsubsection{ACTIVE\_CHARACTER}
{\bf type:} character

The {\it ACTIVE\_CHARACTER} represents the current character controlled by the
user.

\subsubsection{ACTUAL\_MAP}
{\bf type:} string

The {\it ACTUAL\_MAP} represents the current opened map.


\subsection{Imediate Expressions}

\subsubsection{true}
{\bf type:} bool

Represents the true value.

\subsubsection{false}
{\bf type:} bool

Represents the false value.

\subsection{Time}

\subsubsection{wait}
{\bf definition:} bool wait(int s)

The wait function made the script waits for {\it s} seconds before continue to be
interpreted. {\bf Returns:} {\it true} if wait, {\it false} if was interrupted.

{\bf Will generate a Pending Action}

\subsection{Movimentation}

\subsubsection{moveToPosition}
{\bf definition:} bool moveToPosition(character char, int x, int z)

Will move the character {\it char} to the map position {\it x,z}. {\bf Returns:} 
{\it true} if moved, {\it false} if can't move or was interrupted.

{\bf Will generate a Pending Action}

\subsubsection{moveToCharacter}
{\bf definition:} bool moveToCharacter(character char, character tgt)

Will move the character {\it char} near to the character {\it tgt}. {\bf Returns:} 
{\it true} if moved, {\it false} if can't move or was interrupted.

{\bf Will generate a Pending Action}

\subsubsection{moveToObject}
{\bf definition:} bool moveToObject(character char, object obj)

Will move the character {\it char} near to the object {\it obj}. {\bf Returns:} 
{\it true} if moved, {\it false} if can't move or was interrupted.

{\bf Will generate a Pending Action}

\subsection{Character}

\subsubsection{isAlive}
{\bf definition:} bool isAlive(character c)

Verify if a character is alive. {\bf Return} true if the character {\it c} is
alive, or false if its is dead.

\subsubsection{setIdle}
{\bf definition:} void setIdle(character char)

Puts the character {\it char} at idle state.

\subsubsection{getPsycho}
{\bf definition:} int getPsycho(character c)

Gets the psycho state of the character {\it c}. {\bf Return} psycho state of
the character.

\subsubsection{setPsycho}
{\bf definition:} void setPsycho(character c, int psychoState)

Set the psycho state of the character {\it c} to {\it psychoState}.

\subsubsection{getActualLife}
{\bf definition:} int getActualLife(character c)

Gets the current life points of the character {\it c}. {\bf Returns} current
life points of the character.

\subsubsection{getMaxLife}
{\bf definition:} int getMaxLife(character c)

Gets the max life points of the character {\it c}. {\bf Returns} max
life points of the character.

\subsubsection{characterAtRange}
{\bf definition:} characterAtRange(character ref, character target)

Verify if the character {\it target} is at the range of the character {\it ref}.
{\bf Returns:} true if at range, false if isn't.

\subsubsection{canAttack}
{\bf definition:} bool canAttack(character c)

Verify if the character "c" can use attack actions at the current turn.
{\bf Note:} {\it This function only have valid values at the Fight Mode}.

\subsubsection{getNPCByName}
{\bf definition:} character getNPCByName(string pcFile)

Get a NPC character based on its fileName, at the current map.

\subsection{Objects}

\subsubsection{getObject}
{\bf description:} object getObject(string fileName, float posX, float posY,
float posZ)

Get an object pointer at the current map. The object is defined by its {\it
filename} and current position {\it posX, posY, posZ}.

\subsubsection{getObjectState}
{\bf description:} int getObjectState(object obj)

Get the current object state value ({\bf note:} the state is relative to the
object, representing a relative attribute for it, for example, at computers, the
state represents the operational system installed by the active character).

\subsection{Inventory}

\subsubsection{inventoryHave}
{\bf definition:} bool inventoryHave(character owner, string objectFile)

Verify if the inventory of character {\it owner} have the object with fileName
{\it objectFile}. {\bf Returns: } true if have the object, false otherwise.

\subsection{Feat}

\subsubsection{featActualQuantity}
{\bf definition:} int featActualQuantity(string featID)

Get current quantity of the feat {\it featID}.

\subsubsection{featCost}
{\bf definition:} int featCost(string featID)

Get current cost to use the feat {\it featID}.

\subsubsection{featQuantityPerDay}
{\bf definition:} int featQuantityPerDay(string featID)

Get the quantity per day of the feat {\it featID}.

\subsubsection{getRandomAttackFeat}
{\bf definition:} string getRandomAttackFeat()

This function get a random attack feat that can be used by
the characterOwner of the script on its defined target.

\subsubsection{getPowerfullAttackFeat}
{\bf definition:} string getPowerfullAttackFeat()

This function get the powerfull attack feat that the characterOwner
of the script can use at its defined target.

\subsubsection{getRandomHealFeat}
{\bf definition:} string getRandomHealFeat()

This function get a random heal feat that can be used by
the characterOwner of the script on its defined target.

\subsubsection{getPowerfullHealFeat}
{\bf definition:} string getPowerfullHealFeat()

This function get the powerfull heal feat that the characterOwner
of the script can use at its defined target.

\subsubsection{featUseAtCharacter}
{\bf definition:} bool featUseAtCharacter(string feat, character target)

Use a feat at a character.

\subsection{Skill}

\subsubsection{skillPoints}
{\bf definition:} int skillPoints(character c, string skillID)

Get the number of points to the skill {\it skillID} of character {\it c}.

\subsubsection{attModifier}
{\bf definition:} int attModifier(character c, string attID)

Get the Attribute Modifier of attribute {\it attID} of character {\it c}.

\subsection{Fight}

\subsubsection{combatEnter}
{\bf definition:} void combatEnter()

Put the engine at combat mode.

\subsubsection{getNearestEnemy}
{\bf definition:} character getNearestEnemy(character dude)

Get the nearest enemy character from the character {\it dude}

\subsubsection{runAwayFromBattle}
{\bf definition:} void runAwayFromBattle()

The SELF\_CHARACTER will try to run away from the battle (moving to a position
far).


\subsection{Missions}

\subsubsection{missionAdd}
{\bf definition:} void missionAdd(string missionFile)

Add a mission {\it missionFile} to the mission Controller.

\subsubsection{missionComplete}
{\bf definition:} void missionComplete(string missionFile, int completeType)

Complete the mission {\it missionFile} with the {\it completeType} solution.

\subsubsection{missionIsActive}
{\bf definition:} bool missionIsActive(string missionFile)

Verify if the mission is still active {\it (aka: inited and not failed or
completed)}. {\bf Returns: } true if the mission is active.

\subsubsection{missionSetTemp}
{\bf definition:} void missionSetTemp(string missionfile, int tmpNumber, int value)

Set the value of a temporary mission variable {\it tmpNumber}, of mission {\it
missionFile} to {\it value}.


\subsubsection{missionGetTemp}
{\bf definition:} int missionGetTemp(string missionFile, int tmpNumber)

Get the value of the temporary mission variable {\it tmpNumber}, of mission {\it
missionFile};

\subsubsection{missionSetXp}
{\bf definition:} void missionSetXp(string missionFile, int xpValue)

Set the ammount of xp to complete the mission {\it missionFile} to {\it
xpValue}.

\subsection{Dialogs}

\subsubsection{dialogSetInitial}
{\bf definition:} void dialogSetInitial(string charFile, string map, int dlg)

Set the initial dialog for the character repreesented by the character of file
"charFile" at the "map" to the number "dlg".

\subsection{Debug}

\subsubsection{print}
{\bf definition:} void print(string var)

Print the current value of at string variable.

\section{Uses}

The DNT scripts have some specific uses, described bellow.

\subsection{NPC Normal Behaviour}

The script can control a NPC behaviour. This type of scripts, usually, are
{\it infinite loop} ones, controlling all the actions the NPC do when not on
battle mode.

For example, a script tha will made a character walk to two positions and stay
idle for 10 seconds.

\begin{verbatim}
# A general movimentation script to test
# the NPC movimentation controlled by scripts.

script()
   bool control
   int posX posZ
   int time

   control = true
   while(true)
      if(control)
         posX = 3500
         posZ = 3200
         moveToPosition(SELF_CHARACTER, posX, posZ)
         posX = 3600
         posZ = 3200
         moveToPosition(SELF_CHARACTER, posX, posZ)
         control = false
      else
         setIdle(SELF_CHARACTER)
         time = 10
         wait(time)
         control = true
      end
   end
end
\end{verbatim}

\subsection{NPC Combat Controller}
The script can control the combat behaviour of the NPC. They are one pass
scripts types, controlling the character {\bf per turn}. For example:

\begin{verbatim}
#############################################################
# This is a dummy script to control animal combat behaviour
#
# NOTE: the control if character can attack, can move or not
#       is done at the script controller, not at the script
#       (this simplify the script code)
script()

   # Verify if the curren life is too low.
   # If is the case, try to run away
   int curLife
   curLife = getActualLife(SELF_CHARACTER)
   if(curLife < 2)
      runAwayFromBattle()

   # Else (if have enough life, try to attack and be near enemy)
   # Cause it's an animal and don't have range attacks
   else
      # verify if the enemy (active character) is reachable
      if(!characterAtRange(SELF_CHARACTER, ACTIVE_CHARACTER))
         moveToCharacter(SELF_CHARACTER, ACTIVE_CHARACTER)
      end

      # Now, finally, attack the enemy!
      int at
      at = getRandomAttackFeat(ACTIVE_CHARACTER)
      featUseAtCharacter(at, ACTIVE_CHARACTER)
   end

end
\end{verbatim}

\subsection{Missions}

The scripts can control a mission. Mission scripts must define itselves the
ammount of XP characters receive by completing them (with {\it missionSetXp}
function). When {\it missionComplete} or {\it missionAbort} is called, the
script is ended. 

For example, the first tutorial mission.

\begin{verbatim}
# TUTORIAL - I
# The first tutorial mission
# - Found a Chrono Trigger Game for Logan
# NOTE: this mission is controlled between this script and
#       Logan's tutorial dialog.

script()

   int waitTime
   waitTime = 2

   # create the object fileName, since can't have a literal parameter
   string objFile
   objFile = "models/objetos/icex/snes/chrono/snes_chrono.dcc"

   # define logan character
   string logan
   logan = "characters/pcs/logan.pc"   

   # define map where logan is
   string mapa
   mapa = "mapas/tutorial/house1.map"

   # the dialog number
   int dialog
   dialog = 6
   
   while(true)

      if(inventoryHave(ACTIVE_CHARACTER,objFile)) 
         if(dialog == 6)
            # Have the cartridge, set logan talk to get it!
            dialog = 7
            dialogSetInitial(logan, mapa, dialog)            
         end
         # Just a bigger sleep when with the cartridge
         wait(waitTime)
      else 
         if(dialog != 6)
            # Haven't the cartridge, set the logan talk to wait.
            dialog = 6
            dialogSetInitial(logan, mapa, dialog)
         else
            # Verify if logan has the cartdrige: if you barteres with him
            if(inventoryHave(getNPCByName(logan),objFile))
               # Set the dialog to next one
               dialog = 9
               dialogSetInitial(logan, mapa, dialog)

               # You've bartered the cartridge with logan, so finish Mission
               int xp
               int type
               xp = 180
               type = 3
               missionSetXp(SELF_MISSION, xp)
               missionComplete(SELF_MISSION, type)
            end

         end   
      end

      # Wait some time, before the next check
      wait(waitTime)

   end

end
\end{verbatim}

\subsection{Triggers}

Scripts can controll some trigger events, for example, when you open a box, a
trigger script can be called, making a trap or other things. This type of
scripts isn't fully implemented yet.

\end{document}


